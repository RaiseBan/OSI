### Отчет по лабораторной работе №1

---

#### Задание Часть 1. Реализация командной оболочки

**Цель:** Реализовать оболочку командной строки (shell) на ОС Windows, позволяющую запускать программы с переданными аргументами и подсчитывать реальное время их работы.

**Описание реализации:**
- Я реализовал оболочку командной строки, используя системный вызов `CreateProcessAsUser` для запуска программ.
- После завершения каждого процесса, оболочка фиксирует время завершения программы и рассчитывает общее время выполнения как разницу между временем запуска и завершения процесса.
- Операционная система: Windows.

**Пример запуска программы в оболочке:**
```shell
my_shell.exe
Enter command: binary_search.exe 100000 1 250000000
```

**Результат:**
```
Program execution time: X.XXXX sec
```

---

#### Задание Часть 2. Мониторинг и профилирование

**Цель:** Разработать программы-нагрузчики и проанализировать их производительность с помощью инструментов профилирования на Windows.

**Описание программ-нагрузчиков:**
1. **Бинарный поиск:** Программа выполняет бинарный поиск в отсортированном массиве заданного размера и повторяет поиск указанное количество раз.
   - **Параметры запуска:** `binary_search 100000 1 250000000`
   
2. **Поиск подстроки во внешней памяти:** Программа ищет заданную подстроку в большом файле (размером в несколько сотен мегабайт) и выполняет поиск несколько раз для симуляции нагрузки на дисковую подсистему.
   - **Параметры запуска:** `substring_search D:\large_text.txt R7 2`

**Код программ-нагрузчиков:**
```cpp
// binary_search.cpp

// substring_search.cpp
```


### Предполагаемое время выполнения нагрузочных программ

---

### 1. Предсказание времени выполнения для программы `binary_search`

#### Параметры

- **Объем массива**: 100,000 элементов
- **Количество повторений**: 250,000,000
- **Частота процессора**: 2.1 GHz
- **Дополнительные накладные расходы**: переключение контекста и доступ к памяти

#### Оценка количества операций

Бинарный поиск в среднем требует \( \log_2(N) \) операций для поиска одного элемента в массиве из \( N \) элементов. Для массива из 100,000 элементов:
```text
log2(100,000) ≈ 17 операций на поиск
```

Общее количество операций для 250,000,000 повторений:
```text
Total Operations = 250,000,000 × 17 = 4,250,000,000 операций
```

#### Оценка времени выполнения (без учета задержек)

Предполагаем, что для каждой операции бинарного поиска процессор тратит в среднем 3 такта. Тогда общее количество тактов составит:
```text
Total Cycles = 4,250,000,000 × 3 = 12,750,000,000 тактов
```

На процессоре с частотой 2.1 GHz время выполнения (идеализированное) можно оценить как:
```text
Ideal Time = Total Cycles / Processor Frequency = 12,750,000,000 / 2,100,000,000 ≈ 6.07 секунд
```

#### Учёт накладных расходов

Добавим предполагаемые накладные расходы:
- **Задержка на переключение контекста**: 5%
- **Задержка на доступ к памяти**: 10%

С учетом этих факторов:
```text
Adjusted Time = 6.07 × (1 + 0.05 + 0.10) = 6.07 × 1.15 ≈ 6.98 секунд
```

### Ожидаемое время выполнения для `binary_search`: **около 7 секунд** (идеализированно)

---

### 2. Предсказание времени выполнения для программы `substring_search`

#### Параметры

- **Объем файла**: около 500 MB
- **Количество повторений**: 2
- **SSD**: Скорость чтения - около 500 MB/s (с учетом задержек доступа к диску и системных накладных расходов)

#### Оценка времени чтения файла

В программе `substring_search` файл объемом 500 MB читается 2 раза.

1. **Идеальное время для одного чтения**:
```text
Read Time (1 pass) = 500 MB / 500 MB/s = 1 секунда
```

2. **Идеальное время для двух чтений**:
```text
Total Read Time (2 passes) = 2 × 1 = 2 секунды
```

#### Учёт накладных расходов

Для программы `substring_search` также добавим предполагаемые накладные расходы:
- **Задержки на доступ к диску**: 10%
- **Системные задержки и переключение контекста**: 15%

С учетом этих факторов:
```text
Adjusted Read Time = 2 × (1 + 0.10 + 0.15) = 2 × 1.25 = 2.5 секунды
```

### Ожидаемое время выполнения для `substring_search`: **около 2.5 секунд** (идеализированно)

---

### Заключение по предположениям

Ожидаемое время выполнения двух нагрузочных программ с учетом расчетов и накладных расходов:

- **binary_search**: ~7 секунд
- **substring_search**: ~2.5 секунды

Эти оценки являются идеализированными и могут увеличиться в реальной среде из-за накладных расходов на работу операционной системы, конкуренции за ресурсы с другими процессами и потенциальных задержек в подсистеме хранения данных.
```

---

### Эксперименты и результаты профилирования

#### 1. Запуск программ-нагрузчиков и фиксация метрик работы

**Описание:** Запуск каждого нагрузчика отдельно, сбор метрик по CPU, памяти и вводу-выводу.

1. **Бинарный поиск:** 
   - **Параметры запуска:** `binary_search 100000 1 250000000`
   - **Метрики:** CPU, SYS, USER, WAIT, переключения контекста
   - **Скрин профилировщика бинарного поиска**

2. **Поиск подстроки:** 
   - **Параметры запуска:** `substring_search D:\large_text.txt R7 2`
   - **Метрики:** CPU, I/O, USER, SYS, переключения контекста
   - **Скрин профилировщика поиска подстроки**

**Сравнение с ожидаемыми результатами и объяснение:**  
Результаты профилирования показали, что бинарный поиск в основном загружает CPU, тогда как программа поиска подстроки оказывает значительную нагрузку на дисковую подсистему. Это совпадает с первоначальной оценкой.

---

#### 2. Определение количества нагрузчиков для полной загрузки CPU

**Описание эксперимента:** Запуск нескольких экземпляров каждого нагрузчика одновременно и определение, сколько экземпляров необходимо для полной загрузки всех ядер процессора.

- **Методика:** Запускать нагрузчики с помощью shell-скрипта, указав количество экземпляров.
- **Результаты:** 
  - Количество экземпляров для полной загрузки CPU: **X** (для бинарного поиска) и **Y** (для поиска подстроки).
  - **Скрин профилировщика с полным числом экземпляров**

**Показатели:**
- USER%: ___
- SYS%: ___
- WAIT%: ___
- Количество вынужденных переключений контекста: ___
- Количество невынужденных переключений контекста: ___

**Вывод:** С увеличением числа нагрузчиков, система достигает максимальной загрузки всех доступных ядер. Количество переключений контекста возросло, что свидетельствует о нагрузке на планировщик процессов.

---

#### 3. Увеличение числа нагрузчиков вдвое, втрое, вчетверо

**Описание эксперимента:** Увеличение числа экземпляров каждого нагрузчика и анализ изменения производительности.

- **Результаты:**
  - USER%: ___
  - SYS%: ___
  - WAIT%: ___
  - Реальное время выполнения: ___
  - **Скрин профилировщика с увеличенным числом экземпляров**

**Вывод:** При увеличении числа нагрузчиков, процессорные и системные нагрузки увеличиваются. Однако из-за ограничения ресурсов начинает расти WAIT%, что может свидетельствовать о конфликте ресурсов между процессами.

---

#### 4. Объединение нагрузчиков в одну программу с потоками

**Описание эксперимента:** Объединение бинарного поиска и поиска подстроки в одну программу с использованием потоков, что позволяет одному процессу загружать все ядра системы.

- **Методика:** Программа создает два потока – один для выполнения бинарного поиска, другой – для поиска подстроки.
- **Результаты:**
  - USER%: ___
  - SYS%: ___
  - WAIT%: ___
  - Реальное время выполнения: ___
  - **Скрин профилировщика с использованием потоков**

**Вывод:** Использование потоков для параллельной обработки показало более эффективное распределение нагрузки на ядра CPU, что позволило сократить реальное время выполнения.

---

#### 5. Включение агрессивной оптимизации компилятора

**Описание эксперимента:** Скомпилировать программу с агрессивными опциями оптимизации (например, `-O2` или `-O3`) и измерить реальное время выполнения.

- **Результаты:**
  - Реальное время выполнения программы после оптимизации: ___
  - **Скрин профилировщика оптимизированной версии**

**Вывод:** Оптимизация компиляции значительно сократила время выполнения программы за счет улучшения производительности кода. Это подтверждает эффективность компиляторских оптимизаций при работе с интенсивными вычислениями.

---

### Заключение

В ходе лабораторной работы была реализована оболочка командной строки для запуска программ, а также программы-нагрузчики для измерения производительности системы. Проведенные эксперименты показали, как изменяется поведение системы при увеличении нагрузки, использовании многопоточности и оптимизаций компилятора. Инструменты профилирования позволили зафиксировать метрики, такие как USER%, SYS%, WAIT%, количество переключений контекста и другие параметры, что дало представление о влиянии каждой программы на ресурсы системы. 

**Дополнительно:**
- **Таблица результатов для каждой конфигурации (будет добавлена после завершения анализа).**
- **Скриншоты профилировщика для каждой конфигурации (будут добавлены в отчёт).**
